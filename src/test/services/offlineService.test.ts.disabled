import { describe, it, expect, vi, beforeEach } from 'vitest'
import { offlineService } from '../../services/offlineService'

// Mock IndexedDB
const mockIDBDatabase = {
  transaction: vi.fn(() => ({
    objectStore: vi.fn(() => ({
      add: vi.fn().mockResolvedValue({}),
      put: vi.fn().mockResolvedValue({}),
      get: vi.fn().mockResolvedValue({}),
      getAll: vi.fn().mockResolvedValue([]),
      delete: vi.fn().mockResolvedValue({}),
      clear: vi.fn().mockResolvedValue({}),
      createIndex: vi.fn()
    })),
    oncomplete: null,
    onerror: null
  })),
  createObjectStore: vi.fn(() => ({
    createIndex: vi.fn()
  })),
  close: vi.fn()
}

const mockOpenDB = vi.fn().mockResolvedValue(mockIDBDatabase)

// Mock idb
vi.mock('idb', () => ({
  openDB: mockOpenDB
}))

describe('OfflineService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    
    // Mock navigator.onLine
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: true
    })
  })

  describe('Initialization', () => {
    it('should initialize successfully', async () => {
      await offlineService.init()
      expect(mockOpenDB).toHaveBeenCalledWith('CartPilotDB', 3, expect.any(Object))
    })

    it('should handle initialization errors gracefully', async () => {
      mockOpenDB.mockRejectedValueOnce(new Error('DB Error'))
      
      // Should not throw
      await expect(offlineService.init()).resolves.toBeUndefined()
    })
  })

  describe('Online Status', () => {
    it('should report online status correctly', () => {
      Object.defineProperty(navigator, 'onLine', { value: true })
      expect(offlineService.isOnline()).toBe(true)
      
      Object.defineProperty(navigator, 'onLine', { value: false })
      expect(offlineService.isOnline()).toBe(false)
    })
  })

  describe('Cart Management', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should cache cart items', async () => {
      const cartItems = [
        { id: '1', name: 'Milk', completed: false },
        { id: '2', name: 'Bread', completed: true }
      ]

      await offlineService.cacheCartItems(cartItems)
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.put).toHaveBeenCalled()
    })

    it('should retrieve cached cart items', async () => {
      const mockItems = [{ id: '1', name: 'Milk', completed: false }]
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.getAll.mockResolvedValueOnce(mockItems)

      const result = await offlineService.getCachedCartItems()
      expect(result).toEqual(mockItems)
    })

    it('should add offline cart item', async () => {
      const newItem = { id: '1', name: 'Milk', completed: false }

      await offlineService.addOfflineCartItem(newItem)
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.add).toHaveBeenCalled()
    })

    it('should clear cached cart items', async () => {
      await offlineService.clearCachedCartItems()
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.clear).toHaveBeenCalled()
    })
  })

  describe('Store Management', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should cache stores', async () => {
      const stores = [
        { id: '1', name: 'Tesco', address: '123 Main St' },
        { id: '2', name: 'Sainsburys', address: '456 Oak Ave' }
      ]

      await offlineService.cacheStores(stores)
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.put).toHaveBeenCalledTimes(stores.length)
    })

    it('should retrieve cached stores', async () => {
      const mockStores = [{ id: '1', name: 'Tesco', address: '123 Main St' }]
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.getAll.mockResolvedValueOnce(mockStores)

      const result = await offlineService.getCachedStores()
      expect(result).toEqual(mockStores)
    })
  })

  describe('Product Management', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should cache product', async () => {
      const product = {
        barcode: '123456789',
        name: 'Organic Milk',
        brand: 'Organic Valley',
        category: 'Dairy'
      }

      await offlineService.cacheProduct(product)
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.put).toHaveBeenCalledWith(product)
    })

    it('should retrieve cached product by barcode', async () => {
      const mockProduct = {
        barcode: '123456789',
        name: 'Organic Milk',
        brand: 'Organic Valley'
      }
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.get.mockResolvedValueOnce(mockProduct)

      const result = await offlineService.getCachedProduct('123456789')
      expect(result).toEqual(mockProduct)
    })
  })

  describe('Route Management', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should cache route', async () => {
      const route = [
        { name: 'Milk', aisle: 1, section: 'Dairy' },
        { name: 'Bread', aisle: 2, section: 'Bakery' }
      ]

      await offlineService.cacheRoute('store123', route)
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.put).toHaveBeenCalledWith({
        storeId: 'store123',
        route,
        timestamp: expect.any(Number)
      })
    })

    it('should retrieve cached route', async () => {
      const mockRoute = [{ name: 'Milk', aisle: 1, section: 'Dairy' }]
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.get.mockResolvedValueOnce({
        storeId: 'store123',
        route: mockRoute,
        timestamp: Date.now()
      })

      const result = await offlineService.getCachedRoute('store123')
      expect(result).toEqual(mockRoute)
    })
  })

  describe('Sync Queue Management', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should add to sync queue', async () => {
      await offlineService.addToSyncQueue('cart', { userId: 'user123', items: [] })
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.add).toHaveBeenCalledWith({
        type: 'cart',
        data: { userId: 'user123', items: [] },
        timestamp: expect.any(Number),
        id: expect.any(String)
      })
    })

    it('should get sync queue', async () => {
      const mockQueue = [
        { id: '1', type: 'cart', data: {}, timestamp: Date.now() }
      ]
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.getAll.mockResolvedValueOnce(mockQueue)

      const result = await offlineService.getSyncQueue()
      expect(result).toEqual(mockQueue)
    })

    it('should clear sync queue', async () => {
      await offlineService.clearSyncQueue()
      
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      expect(store.clear).toHaveBeenCalled()
    })
  })

  describe('Sync Operations', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should trigger sync when online', async () => {
      const consoleSpy = vi.spyOn(console, 'log')
      
      await offlineService.syncWhenOnline()
      
      expect(consoleSpy).toHaveBeenCalledWith('ðŸ”„ Syncing offline data...')
    })

    it('should not sync when offline', async () => {
      Object.defineProperty(navigator, 'onLine', { value: false })
      
      const consoleSpy = vi.spyOn(console, 'log')
      
      await offlineService.syncWhenOnline()
      
      expect(consoleSpy).toHaveBeenCalledWith('ðŸ“µ Still offline, sync will retry when connection is restored')
    })
  })

  describe('Storage Information', () => {
    beforeEach(async () => {
      await offlineService.init()
    })

    it('should get storage info', async () => {
      const info = await offlineService.getStorageInfo()
      
      expect(info).toHaveProperty('cartItems')
      expect(info).toHaveProperty('stores')
      expect(info).toHaveProperty('products')
      expect(info).toHaveProperty('routes')
      expect(info).toHaveProperty('syncQueue')
    })
  })

  describe('Error Handling', () => {
    it('should handle database errors gracefully', async () => {
      const transaction = mockIDBDatabase.transaction()
      const store = transaction.objectStore()
      store.add.mockRejectedValueOnce(new Error('DB Error'))

      // Should not throw
      await expect(
        offlineService.addOfflineCartItem({ id: '1', name: 'Test', completed: false })
      ).resolves.toBeUndefined()
    })

    it('should handle missing database gracefully', async () => {
      // Don't initialize the service
      const result = await offlineService.getCachedCartItems()
      expect(result).toEqual([])
    })
  })
})